# 函数详解及作用域和预解析

## function 的 this 指向
function中，谁调用了这个function，this就指向谁,如下例:
`
    function fn(){
        console.log(this);
    };
    document.fn = fn; 
    document.fn(); // document
    document.body.f = fn;
    document.body.f(); // body
    fn(); // window
`


## 获取计算后样式
计算后样式: 当前元素展现出来的样式，也可以说优先级最高的一条的样式

- window.getComputedStyle() 注意：window下的属性或者方法在书写时可以省略window 直接写作getComputedStyle()
    - 作用: 用来获取计算后样式
    - 语法: object window.getComputedStyle(element);
    - 参数: element 要获取样式的元素
    - 返回值: 包含了元素虽有样式的对象
    - 不兼容 IE8及以下版本的IE浏览器
- el.currentStyle IE低版本下 获取计算后样式   
- currentStyle 不能获取复合样式

## 箭头函数

- 语法：
    - 参数=>返回值
    - (参数1,参数2) => 返回值
    - 参数1 => {//执行语句;return 返回值;}
    - (参数1,参数2) => {//执行语句;return 返回值;}
    - ()=>{执行语句;}
- 箭头函数中没有 arguments
- 箭头函数的this指向其声明时，所在的作用域的this 

## rest 参数
接受函数的剩余参数，把剩余参数放入数组
语法如下:
`
    function fn(参数1,参数2,...rest参数名字){
        console.log(rest参数名字);
    }
`

## 预解析
在js中，每读到一个样式表，就会先进行预解析。js 的预解析主要针对两个关键字 一个 是 var 和 function。预解析完之后，会一行一行的向下执行代码

### var 的预解析(变量提升)
当js解读到一个样式表(作用域)时，会先把这个样式表的 var 关键字找出来，然后把 var 及 它声明的变量名，提升至 样式表(作用域)的最前方;

### function 的预解析
当js解读到一个样式表(作用域)时，会先把这个样式表的 function 关键字, 然后把function 声明的整个函数，提升至样式表(作用域)的前方,跟在 var 之后;

## 作用域
作用域: 一个数据或者说一段代码可以在哪些范围内使用

### 全局作用域
- 全局变量：声明在全局（任何局部作用域以外）的变量，在全局任意地方都可以调用和修改
- 变量如果不声明的话，就会变成全局变量
- 加在一些全局对象上的属性或方法，也是可以在全局都进行使用的
- 不建议使用全局变量，会造成全局污染,容易变量命名冲突

### 函数作用域（局部作用域）
- 我们声明在函数中的变量，以及函数本身的参数,这些数据只能在这个函数内部使用，所以这些叫做这个函数的局部变量
- 在函数中有一个内部属性 [[scope]],当我们执行函数时，就会把声明在这个函数中数据，存入 [[scope]], 在函数中调用数据时 也会从 [[scope]] 查找数据

### 作用域链
作用域链式一种数据查找规则。我们调用一条数据时，会现在本作用域内部进行查找,查找不到的话，就去父作用域查找，一层一层向上直到找到 全局作用域, 如果在全局作用域还找不到就报错;

### 闭包
闭包是函数和声明该函数的词法环境的组合。
- 形式： 函数中嵌套了一个函数
- 重点： 子级访问父级的作用域，但是父级不能访问子级的作用域。
- 闭包包含自由（未绑定到特定对象）变量，这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。“闭包” 一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域）。

## let 和 const
### let 变量
- let 在同一作用域中不能重复声明
- let 不会预解析
- let 不同 var 只有 函数作用域, let 是块级作用域
- 块级作用域: {代码块}

### const 常量
- 在同一作用域中不能重复声明
- 不会预解析
- 会产生块级作用域
- 常量一但不可更改